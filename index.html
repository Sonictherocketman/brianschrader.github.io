<!DOCTYPE HTML>
<html>
<head>
	<title>Home - BiteofanApple</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">

	<link rel="stylesheet" type="text/css" href="/bin/CSS/stylesheet.css">
	<link rel="stylesheet" type="text/css" href="/bin/CSS/mobile.css">

	<link rel="shortcut icon" href="http://images.biteofanapple.com/misc/favicon.ico">
	<link rel="icon" href="http://images.biteofanapple.com/misc/favicon.ico">
	<link rel="apple-touch-icon-precomposed" href="http://images.biteofanapple.com/misc/apple-touch-icon-precomposed.png"/>  

	<meta property="og:title" content="[TITLE]" />
	<meta property="og:type" content="article" />
	<meta property="og:url" content="[LINK]" />	

	<script type="text/javascript" src="/bin/jquery-1.9.1.min.js"></script>
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-48095792-1', 'auto');
	  ga('send', 'pageview');

	</script>
</head>
<body>
	<div id="content">
		<div id="title-bar">
			<!-- Desktop Nav -->
			<!-- Name and Author -->
			<span class="menuBarItem" style="margin-left: 10px; font-size:2em;"><a href="/">BiteofanApple</a></span>
				<!-- Links -->
				<span class="menuBarItem" style="margin-left: 40px;"><a href="/archive/">Archive</a></span>
				<span class="menuBarItem"><a href="/about/">About</a></span>
				<span class="menuBarItem"><a href="https://github.com/Sonictherocketman">Code</a></span>
				<span class="menuBarItem"><a href="http://www.twitter.com/SonicRocketman/">Twitter</a></span>
				<br>
				<span class="menuBarItem" style=" position:absolute; margin-top:-80px; margin-left:10px; font-size:10pt; font-style:italic;">by <a href="/about/">Brian Schrader</a></span>
			</span>	

			<!-- Mobile Nav -->
			<div class="mobile-nav">
				<!-- Name and Author -->
				<div style="text-align:center; margin-top:-20pt;">
					<span class="" style="font-size:2em;"><a href="/">BiteofanApple</a></span>
				</div>
				<!-- Links -->
				<div style="margin-top:2%;">
					<span class="mobileMenuBarItem" style=""><a href="/archive/">Archive</a></span>
					<span class="mobileMenuBarItem"><a href="/about/">About</a></span>
					<span class="mobileMenuBarItem"><a href="https://github.com/Sonictherocketman">Code</a></span>
					<span class="mobileMenuBarItem"><a href="http://www.twitter.com/SonicRocketman/">Twitter</a></span>
				</div>
			</div>	
		</div>	<!-- End title-bar -->
		<div id="post-list">
			<article>
	<div class="post">
		<div class="article-title">
			<h1><a href="/archive/even-more-re-software-and-engineering/">
					Even more re: software and engineering
				</a>
			</h1>
			<small style="font-style:italic;">Posted on Mon, 09 Nov 2015 at 01:11 PM </small>
		</div> <!-- End article-title -->
		<div class="article-content">
			<p><a href="http://www.leancrew.com/all-this/">Dr. Drang:</a></p>
<blockquote>
<p>...the difference between hacking and software engineering is like the
 difference between carpentry and structural engineering. The carpenter takes
 lumber and nails it together in a way that seems right, while the structural
 engineer sizes and spaces the lumber using a rational approach based on the
 applied loads and the strength of the material... </p>
<p>But there’s a place for carpentry. If you’re building a shed in your backyard,
there’s no need for a structural engineer. The rules of thumb of
carpentry—which can be shown to have rational bases, even though the carpenter
may not know them—are perfectly adequate to build a strong and durable shed.
The trick is to know when you need structural engineering and when you can get
by with carpentry.</p>
</blockquote>
<p><a href="http://www.theatlantic.com/technology/archive/2015/11/programmers-should-not-call-themselves-engineers/414271/?single_page=true#article-comments">Ian Bogost</a></p>
<blockquote>
<p>The term is probably a shortening of “software engineer,” but its use betrays
a secret: “Engineer” is an aspirational title in software development.
Traditional engineers are regulated, certified, and subject to apprenticeship
and continuing education. Engineering claims an explicit responsibility to
public safety and reliability, even if it doesn’t always deliver.</p>
<p>The title “engineer” is cheapened by the tech industry...</p>
<p>The traditional disciplines of engineering—civil, mechanical, aerospace,
chemical, electrical, environmental—are civic professions as much as
technical ones. Engineers orchestrate the erection of bridges and buildings;
they design vehicles and heavy machinery; they invent and realize the energy
systems that drive this equipment; and they contrive methods for connecting
all of these systems together...</p>
<p>It’s no accident that the most truly engineered of software-engineering
projects extend well beyond the computer. Autonomous-vehicle design offers
the most obvious contemporary example. Autonomous vehicles share the roads 
with human-driven cars, pedestrians, and bicyclists. Those roads are managed, 
maintained, and regulated. 
Engineering addresses complex, large-scale systems...</p>
<p>Other engineering disciplines are subject to certification and licensure... </p>
<p>Licensing processes vary by state, but
Professional Engineers generally need to hold a 4-year degree from an
accredited program in their discipline, pass one or more exams, and possess 4
or more years of professional experience under the supervision of a licensed
engineer. Not all working engineers are or need to be Professional Engineers,
but... to claim that one is an “engineer” in a formal context, licensure is 
usually required...</p>
<p>Engineers bear a burden to the public, and their specific expertise as
designers and builders of bridges or buildings—or software—emanates from that
responsibility.</p>
</blockquote>
<p>These two posts sum up my feelings pretty well.  </p>
		</div>
	</div>
</article>
<article>
	<div class="post">
		<div class="article-title">
			<h1><a href="/archive/why-im-switching-back-to-itunes/">
					Why I'm switching back to iTunes
				</a>
			</h1>
			<small style="font-style:italic;">Posted on Mon, 12 Oct 2015 at 02:55 PM </small>
		</div> <!-- End article-title -->
		<div class="article-content">
			<p>Last week I decided to leave Spotify. I've been using the
service for almost 2 years now, and overall I've really liked it. Their
selection is great, their ability to stream audio over even the slowest
connection is constantly impressive, and while the app's UI isn't perfect, it
has gotten much better. As I said, I've really liked having Spotify, so why 
am I leaving?</p>
<p><img alt="Cancelling spotify" src="/images/blog/cancel-spotify.png" /></p>
<p>Like <a href="http://www.audible.com">another service that I used to pay for but just cancelled</a>, Spotify
hasn't sat well with me over the last few months. It's hard to explain why, but
I guess I feel apprehensive about Spotify being in control of how and where I
listen to music in ways I haven't been before. An example of my frustration 
happened last week when I was trying to AirPlay some music from the Spotify app 
on my iPhone to my media center running <a href="https://osmc.tv">OSMC</a>. When I went looking in the 
AirPlay settings for a destination, my media center showed up, but it wasn't playing.
Originally I thought it might be a bug between OSMC's AirPlay implementation and 
iOS 9, but when I tried streaming from the music app it worked fine. It also
worked fine from iTunes on my Mac, but not from Spotify.
This was extremely frustrating at the time, and it helped me reconcile the
feelings that I'd been having toward Spotify in the recent months. Spotify is a
great service, but like all proprietary services, it gets to decide
how/why/where you can use it's material. This wasn't the first time I'd felt
stuck because of Spotify's imposed limitations, it was just the last straw. I 
decided to resurrect my old music library, <a href="https://twitter.com/sonicrocketman/status/651874066702319616">give iTunes a new icon</a>, purchase 
the music I wanted outright, and cancel Spotify.
<sup>1</sup></p>
<p><img alt="Getting a new icon" src="/images/blog/new-itunes-icon.png" /></p>
<p>Now I know that iTunes is proprietary software with it's own set of limitations
and hurdles, but the music I've purchased from it is mine. I have access to the
raw audio files, and I can convert, burn, and AirPlay them anywhere I want. As
long as it is technically possible to AirPlay to a device it should work, and 
that's becoming more and more important to me. </p>
<p>iTunes is not a great piece of software; it's overcrowded with features, and
begging for a redesign and simplification, but with it's latest release it has
gotten better. Once I cleaned out my old music library and basically started
from scratch, I've really enjoyed using it, and with iCloud music library, I 
get the my-music-is-always-on-whatever-device-I'm-using benefit of a streaming 
service. Although I now have to go back and purchase my favorite albums
again, overall I'm happy with my decision. </p>
<div class="footnote">

1. Another reason I've wanted to switch away from Spotify that is less relevant to
this discussion is that since I don't usually listen to a new album every
month, the cost of paying for a streaming service monthly is a little hard to
justify.

</div>
		</div>
	</div>
</article>
<article>
	<div class="post">
		<div class="article-title">
			<h1><a href="/archive/disable-shake-to-find-cursor-in-el-capitan/">
					Disable "shake to find cursor" in El Capitan
				</a>
			</h1>
			<small style="font-style:italic;">Posted on Mon, 12 Oct 2015 at 11:35 AM </small>
		</div> <!-- End article-title -->
		<div class="article-content">
			<p>I've been using Mac OX 10.10 El Capitan for a few days now, and it's been
fairly solid for me. I've encountered some minor bugs, but overall it's a solid
point-oh release.</p>
<p>One new feature that I'm not too fond of, however, is the new "shake to find your
cursor" thing. I really don't know why it bugs me, but it does. So I went
looking for a way to disable it.</p>
<p>The solution is pretty simple. Run the following command in Terminal, and
reboot your machine. </p>
<pre><code>defaults write ~/Library/Preferences/.GlobalPreferences CGDisableCursorLocationMagnification -bool YES
</code></pre>
<p><a href="http://forums.macrumors.com/threads/disabling-shake-to-find-cursor.1892341/">Original Post &#8594;</a></p>
		</div>
	</div>
</article>
<article>
	<div class="post">
		<div class="article-title">
			<h1><a href="/archive/software-correctness-and-software-engineering/">
					Software Correctness and Software Engineering
				</a>
			</h1>
			<small style="font-style:italic;">Posted on Mon, 05 Oct 2015 at 04:50 PM </small>
		</div> <!-- End article-title -->
		<div class="article-content">
			<p><a href="http://www.drmaciver.com/2015/10/the-economics-of-software-correctness/">David R. MacIver:</a></p>
<blockquote>
<p>You have probably never written a significant piece of correct software.</p>
<p>...the chances of having written whole programs which are [bug free] are 
tantamount to zero.</p>
<p>It’s not because we don’t know how to write correct software. We’ve known how
to write software that is more or less correct (or at least vastly closer to
correct than the norm) for a while now. If you look at the NASA development
process they’re pretty much doing it.</p>
<p>The problem is not that we don’t know how to write correct software. The
problem is that correct software is too expensive.</p>
</blockquote>
<p>David's post covers quite a few very important points, and while I've <a href="/archive/software-engineering/">covered 
this issue before</a>, I think it bears diving back into. </p>
<p>Software Engineering isn't like any other form of engineering. It has nowhere
near the maturity of the classical engineering fields, and it's poisoned by a
"shipping culture" wherein getting software into the user's hands is more
important than that software actually working properly. Now, this isn't to say
that product companies and start-ups are wrong, but this culture
has soured our mental model of how engineering works. Engineering is the
process of designing, developing, maintaining, and predicting the behavior of
some device or structure. According to the American Engineer's Council for
Professional Development, the <a href="https://en.wikipedia.org/wiki/Engineering#Definition">definition of engineering</a> is (emphasis mine): </p>
<blockquote>
<p>The creative application of scientific principles to design or develop
structures, machines, apparatus, or manufacturing processes, or works
utilizing them singly or in combination; or to construct or operate the same
with full cognizance of their design; or <strong>to forecast their behavior under
specific operating conditions; all as respects an intended function,
economics of operation or safety to life and property.</strong></p>
</blockquote>
<p>That last part is important when it comes to Software Engineering. Forecasting
the behavior of a system and being able to say it respects the user's safety to 
life and property is something that most developers don't consider when
building their software. Why?</p>
<blockquote>
<p>The rest of us aren’t writing safety critical software, and as a result
people aren’t willing to pay for that level of correctness.</p>
</blockquote>
<p>This is in stark contrast to, for example, the way that NASA develops software.
At NASA, software is treated as just another branch of engineering/development.
It's design goes through the same rigorous review that their rocket engines,
and safety harnesses do. Why? Because a failure in software could cost
<em>billions</em> of dollars, and possibly kill people. These are stakes that software
like Twitter and iTunes will never have to face, thankfully (iTunes would kill
us all).</p>
<p>David links to an article, originally from the mid-90s, detailing NASA's
software development process. Their process is extremely boring, and has tons 
of overhead. The code is designed, <strong>line by line</strong> in pseudo-code before ever 
being typed into an editor. Engineers then just write the code exactly as it's 
outlined in 3,000+ line blueprints. </p>
<p><a href="http://www.fastcompany.com/28121/they-write-right-stuff">Charles Fishman:</a></p>
<blockquote>
<p>That's the culture: the on-board shuttle group produces grown-up software,
and the way they do it is by being grown-ups. It may not be sexy, it may not
be a coding ego-trip — but it is the future of software. When you're ready to
take the next step — when you have to write perfect software instead of
software that's just good enough — then it's time to grow up.</p>
<p>It's the process that allows them to live normal lives, to set deadlines they
actually meet, to stay on budget, to deliver software that does exactly what
it promises. It's the process that defines what these coders in the flat
plains of southeast suburban Houston know that everyone else in the software
world is still groping for. It's the process that offers a template for any
creative enterprise that's looking for a method to produce consistent - and
consistently improving — quality.</p>
</blockquote>
<p>This sounds, frankly, crazy, and no software focused company would want to adopt
a system like this, and I can't blame them. It does not sound like fun, but it 
does sound like the code will be correct and largely error free. Obviously this 
method doesn't work for a lot of use cases in the world of Software Development,
and that's ok. One of the bonuses of writing non-critical software is that it
doesn't have to be 100% correct, it can have bugs and fix them over time. I
think one of the best moments for a piece of software, though, is after it
becomes fairly successful, and it decided to grow-up and start focusing on
stability, consistency, and correctness. We see these waves of new features and
lulls of stability releases in a lot of consumer software these days; Mac OS X
is a notable example. </p>
<p>In my mind though, developers should take a page out of NASA's book, and take
their products more seriously. Engineering software is a time consuming,
precise operation, and it should be given the respect and care it deserves.  </p>
<p>NASA is able to send a probe to Pluto, on a 15 year journey, collect the first 
ever pictures of the dwarf planet, and send them back to earth <em>automatically</em> 
with code written <em>2 decades ago</em> that hasn't needed to be updated since it 
launched. That's damn near perfect software; that's real Software Engineering.</p>
<p><a href="http://www.drmaciver.com/2015/10/the-economics-of-software-correctness/">The economics of software correctness &#8594;</a></p>
<p><a href="http://www.fastcompany.com/28121/they-write-right-stuff">They Write the Right Stuff
&#8594;</a></p>
		</div>
	</div>
</article>
<article>
	<div class="post">
		<div class="article-title">
			<h1><a href="/archive/how-to-save-your-team-from-the-evil-testing-demons/">
					How to save your team from the evil testing demons
				</a>
			</h1>
			<small style="font-style:italic;">Posted on Thu, 24 Sep 2015 at 09:54 AM </small>
		</div> <!-- End article-title -->
		<div class="article-content">
			<p>So your team has succumb to the evil testing overlords. They constantly talk 
about Unit Tests, Continuous Integration, and Code Coverage. How is programming 
supposed to be fun if the code does the same thing every time? Where's the 
sense of adventure? Fear not, the art of cowboy coding is not dead. You can 
save your teammates from the testing demons with these tips. </p>
<ul>
<li>
<p>The first mistake people make when trying to rid their teams of the evil
  testing demons is being too hasty. You have to destroy the tests from the
  inside. </p>
</li>
<li>
<p>Write tests for all of your modules, but make it so that the tests only
  pass in very specific use cases. This will cause confusion and plant that
  crucial seed of doubt.</p>
</li>
<li>
<p>Make test functions appear to test one thing, then actually test something
  completely different. The easiest way to do this is to label the test function 
  incorrectly. That is, the test for <code>do_get</code> should be called <code>test_do_post</code>. </p>
</li>
<li>
<p>Write integration tests in place of unit tests. This will cause the unit
  tests to get really slow over time and make your coworkers think twice about
  running them constantly. This is important because once your coworkers are
  free from constantly testing, they'll start to question the utility of the
  tests as a whole.</p>
</li>
<li>
<p>Write functions that don't return anything. Instead have them modify internal
  state. Write functions that should return something, but instead put the
  return value in one of the parameters.</p>
</li>
<li>
<p>This one is key, write monolithic functions that accomplish a lot at once.
  Did you know that function calls are computationally expensive? Don't use
  them.</p>
</li>
<li>
<p>Write functions that take complex object as parameters, who's values have to
  be configured very particularly. The function should return the same object.</p>
</li>
<li>
<p>On the same note, pass complicated variables around into other functions.
  That way the tests for those functions will have to mock the complex object.</p>
</li>
<li>
<p>Use application state. Lots of it. Write code so that functions depend on
  very particular settings in the global state to be configured. Not only does
  this make them harder to test, the tests will need to mock this state which
  causes them to run slower, thus enforcing the idea that the tests aren't
  helping.</p>
</li>
<li>
<p>Did you know that functions that don't have parameters and that don't return
  anything are really difficult to test? Write lots of those. Remember, you're
  fighting for the future of programming. Down with the suites! Long live the
  cowboys and cowgirls!</p>
</li>
<li>
<p>Constantly blame the tests for not finding new bugs. Explain that it's
  impossible to predict user behavior. How can you test something that's
  impossible to predict?</p>
</li>
<li>
<p>On build days, commit code with failing tests that prevent the CI from
  auto-deploying the new build, then blame the stupid CI for not mocking your 
  test cases properly. Assert that something is wrong internally with the CI
  system.  </p>
</li>
<li>
<p>Testing requires a lot of tools and setup. Assert that you can't be 'agile' 
  (a good buzzword) if you have to set up all of this stuff. How can you
  possibly keep up with Grunt, Travis, Mock, Mocha, Istanbul, Karma, and more?</p>
</li>
<li>
<p>Make the case, "I can't write tests if I don't know what the app is going to
  do yet." Everyone knows that it's impossible to think through the code before
  writing it. Code is art and you're an inspired artist.</p>
</li>
<li>
<p>Constantly remind everyone that they aren't doing <em>real</em> test driven
  development. Tell them, "You know, real TDD is where you write the tests
  first. Why are we doing this half way?" When they complain that they don't
  like writing the tests first, tell them that they may as well not do
  tests at all if they aren't that committed.</p>
</li>
<li>
<p>When your team members write tests, explain that, according to the rules of
  TDD, if they aren't writing tests that fail at first, then they don't really
  know if the tests are valid. Ask them if they write failing tests first. If
  they say no, then tell them that their tests are essentially meaningless.</p>
</li>
<li>
<p>Whenever you write new code, explain that you don't have time to write tests.
  You're on a deadline. If the people that have time to write tests want to do
  it then fine, but you're trying to get actual work done.</p>
</li>
<li>
<p>Insist that the tests need to be run against real data, and that generating data
  or storing fixtures will never be adequate. Testing, as an idea, is
  fundamentally broken.</p>
</li>
<li>
<p>Make environment checks throughout your code to ensure that it will only run
  in production, and can only be tested in production. Then make sure to exit 
  early if any other environment is detected with no error codes.</p>
</li>
<li>
<p>Make any magic variable settings into database values.</p>
</li>
<li>
<p>Test the core language features; you can’t be sure your iterator variable
  will increment unless you write a test that validates you can add one to a
  variable. Doing this will slow your test suite down even more, adding to the
  irritation.</p>
</li>
<li>
<p>Defeat the testing demons from the inside. Whenever your writing superflous
  tests, use lots of mocks and test every tiny piece of your code (e.g. when 
  making a settings dictionary, mock out everything except the dict creation 
  and test just that one bit). This will help you write tons of mocks for each 
  test. Changing anything will break lots of the mocks and make half the test 
  suite fail with import path errors unrelated to the change. </p>
</li>
<li>
<p>Whenever your team members get too proud of their service to the testing
  devils, ask them if they test their tests. If they don't, how do they know
  that they work properly. They will quickly realize the paradox of testing and
  quit.</p>
</li>
</ul>
<p>Remember, you're trying to show your team that testing is a failed idea. You're
trying to bring back the good ol' days when programmers roamed free, not caged
in the predictable, safe confines of test driven development. You're doing this
for your team; someday they'll thank you.</p>
<hr />
<p>Thanks to <a href="https://twitter.com/AdamAndDevOps">@AdamAndDevOps</a>, <a href="https://twitter.com/macromicah">@macromicah</a>, <a href="https://twitter.com/TheDudestMonk">@TheDudestMonk</a>, and <a href="https://twitter.com/tanyxp">@Tanyxp</a> for their additions.</p>
		</div>
	</div>
</article>	
			<div class="post">
				<div class="article-title"><a href="/archive/"><h3>Archive</h3></a></div>
			</div>
			<div style="text-align:center;">
				<div class="article-content">
					<span style="font-style:italic;">Subscribe to the <a href="/rss">RSS Feed</a>. Check out my code on <a href="http://github.com/sonictherocketman/">GitHub</a></span>
				</div>
				<div class="article-content">
					<span style="font-size:small;">
						<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
						<img alt="Creative Commons License" style="border-width:0" src="/images/misc/cc-license.png" />
						</a>
					<br />
					<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">BiteofanApple</span> is licensed under a 
					<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
				</div>
			</div>	
		</div> <!-- End post-list -->
	</div> <!-- End content -->
</body>
</html>
