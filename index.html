<!DOCTYPE HTML>
<html>
<head>
	<title>Home - BiteofanApple</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">

	<link rel="stylesheet" type="text/css" href="/bin/CSS/stylesheet.css">
	<link rel="stylesheet" type="text/css" href="/bin/CSS/mobile.css">

	<link rel="shortcut icon" href="http://images.biteofanapple.com/misc/favicon.ico">
	<link rel="icon" href="http://images.biteofanapple.com/misc/favicon.ico">
	<link rel="apple-touch-icon-precomposed" href="http://images.biteofanapple.com/misc/apple-touch-icon-precomposed.png"/>  

	<meta property="og:title" content="[TITLE]" />
	<meta property="og:type" content="article" />
	<meta property="og:url" content="[LINK]" />	

	<script type="text/javascript" src="/bin/jquery-1.9.1.min.js"></script>
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-48095792-1', 'auto');
	  ga('send', 'pageview');

	</script>
</head>
<body>
	<div id="content">
		<div id="title-bar">
			<!-- Desktop Nav -->
			<!-- Name and Author -->
			<span class="menuBarItem" style="margin-left: 10px; font-size:2em;"><a href="/">BiteofanApple</a></span>
				<!-- Links -->
				<span class="menuBarItem" style="margin-left: 40px;"><a href="/archive/">Archive</a></span>
				<span class="menuBarItem"><a href="/about/">About</a></span>
				<span class="menuBarItem"><a href="https://github.com/Sonictherocketman">Code</a></span>
				<span class="menuBarItem"><a href="http://www.twitter.com/SonicRocketman/">Twitter</a></span>
				<br>
				<span class="menuBarItem" style=" position:absolute; margin-top:-80px; margin-left:10px; font-size:10pt; font-style:italic;">by <a href="/about/">Brian Schrader</a></span>
			</span>	

			<!-- Mobile Nav -->
			<div class="mobile-nav">
				<!-- Name and Author -->
				<div style="text-align:center; margin-top:-20pt;">
					<span class="" style="font-size:2em;"><a href="/">BiteofanApple</a></span>
				</div>
				<!-- Links -->
				<div style="margin-top:2%;">
					<span class="mobileMenuBarItem" style=""><a href="/archive/">Archive</a></span>
					<span class="mobileMenuBarItem"><a href="/about/">About</a></span>
					<span class="mobileMenuBarItem"><a href="https://github.com/Sonictherocketman">Code</a></span>
					<span class="mobileMenuBarItem"><a href="http://www.twitter.com/SonicRocketman/">Twitter</a></span>
				</div>
			</div>	
		</div>	<!-- End title-bar -->
		<div id="post-list">
			<article>
	<div class="post">
		<div class="article-title">
			<h1><a href="/archive/how-to-save-your-team-from-the-evil-testing-demons/">
					How to save your team from the evil testing demons
				</a>
			</h1>
			<small style="font-style:italic;">Posted on Thu, 24 Sep 2015 at 09:54 AM </small>
		</div> <!-- End article-title -->
		<div class="article-content">
			<p>So your team has succumb to the evil testing overlords. They constantly talk 
about Unit Tests, Continuous Integration, and Code Coverage. How is programming 
supposed to be fun if the code does the same thing every time? Where's the 
sense of adventure? Fear not, the art of cowboy coding is not dead. You can 
save your teammates from the testing demons with these tips. </p>
<ul>
<li>
<p>The first mistake people make when trying to rid their teams of the evil
  testing demons is being too hasty. You have to destroy the tests from the
  inside. </p>
</li>
<li>
<p>Write tests for all of your modules, but make it so that the tests only
  pass in very specific use cases. This will cause confusion and plant that
  crucial seed of doubt.</p>
</li>
<li>
<p>Make test functions appear to test one thing, then actually test something
  completely different. The easiest way to do this is to label the test function 
  incorrectly. That is, the test for <code>do_get</code> should be called <code>test_do_post</code>. </p>
</li>
<li>
<p>Write integration tests in place of unit tests. This will cause the unit
  tests to get really slow over time and make your coworkers think twice about
  running them constantly. This is important because once your coworkers are
  free from constantly testing, they'll start to question the utility of the
  tests as a whole.</p>
</li>
<li>
<p>Write functions that don't return anything. Instead have them modify internal
  state. Write functions that should return something, but instead put the
  return value in one of the parameters.</p>
</li>
<li>
<p>This one is key, write monolithic functions that accomplish a lot at once.
  Did you know that function calls are computationally expensive? Don't use
  them.</p>
</li>
<li>
<p>Write functions that take complex object as parameters, who's values have to
  be configured very particularly. The function should return the same object.</p>
</li>
<li>
<p>On the same note, pass complicated variables around into other functions.
  That way the tests for those functions will have to mock the complex object.</p>
</li>
<li>
<p>Use application state. Lots of it. Write code so that functions depend on
  very particular settings in the global state to be configured. Not only does
  this make them harder to test, the tests will need to mock this state which
  causes them to run slower, thus enforcing the idea that the tests aren't
  helping.</p>
</li>
<li>
<p>Did you know that functions that don't have parameters and that don't return
  anything are really difficult to test? Write lots of those. Remember, you're
  fighting for the future of programming. Down with the suites! Long live the
  cowboys and cowgirls!</p>
</li>
<li>
<p>Constantly blame the tests for not finding new bugs. Explain that it's
  impossible to predict user behavior. How can you test something that's
  impossible to predict?</p>
</li>
<li>
<p>On build days, commit code with failing tests that prevent the CI from
  auto-deploying the new build, then blame the stupid CI for not mocking your 
  test cases properly. Assert that something is wrong internally with the CI
  system.  </p>
</li>
<li>
<p>Testing requires a lot of tools and setup. Assert that you can't be 'agile' 
  (a good buzzword) if you have to set up all of this stuff. How can you
  possibly keep up with Grunt, Travis, Mock, Mocha, Istanbul, Karma, and more?</p>
</li>
<li>
<p>Make the case, "I can't write tests if I don't know what the app is going to
  do yet." Everyone knows that it's impossible to think through the code before
  writing it. Code is art and you're an inspired artist.</p>
</li>
<li>
<p>Constantly remind everyone that they aren't doing <em>real</em> test driven
  development. Tell them, "You know, real TDD is where you write the tests
  first. Why are we doing this half way?" When they complain that they don't
  like writing the tests first, tell them that they may as well not do
  tests at all if they aren't that committed.</p>
</li>
<li>
<p>When your team members write tests, explain that, according to the rules of
  TDD, if they aren't writing tests that fail at first, then they don't really
  know if the tests are valid. Ask them if they write failing tests first. If
  they say no, then tell them that their tests are essentially meaningless.</p>
</li>
<li>
<p>Whenever you write new code, explain that you don't have time to write tests.
  You're on a deadline. If the people that have time to write tests want to do
  it then fine, but you're trying to get actual work done.</p>
</li>
<li>
<p>Insist that the tests need to be run against real data, and that generating data
  or storing fixtures will never be adequate. Testing, as an idea, is
  fundamentally broken.</p>
</li>
<li>
<p>Make environment checks throughout your code to ensure that it will only run
  in production, and can only be tested in production. Then make sure to exit 
  early if any other environment is detected with no error codes.</p>
</li>
<li>
<p>Make any magic variable settings into database values.</p>
</li>
<li>
<p>Test the core language features; you canâ€™t be sure your iterator variable
  will increment unless you write a test that validates you can add one to a
  variable. Doing this will slow your test suite down even more, adding to the
  irritation.</p>
</li>
<li>
<p>Defeat the testing demons from the inside. Whenever your writing superflous
  tests, use lots of mocks and test every tiny piece of your code (e.g. when 
  making a settings dictionary, mock out everything except the dict creation 
  and test just that one bit). This will help you write tons of mocks for each 
  test. Changing anything will break lots of the mocks and make half the test 
  suite fail with import path errors unrelated to the change. </p>
</li>
<li>
<p>Whenever your team members get too proud of their service to the testing
  devils, ask them if they test their tests. If they don't, how do they know
  that they work properly. They will quickly realize the paradox of testing and
  quit.</p>
</li>
</ul>
<p>Remember, you're trying to show your team that testing is a failed idea. You're
trying to bring back the good ol' days when programmers roamed free, not caged
in the predictable, safe confines of test driven development. You're doing this
for your team; someday they'll thank you.</p>
<hr />
<p>Thanks to <a href="https://twitter.com/AdamAndDevOps">@AdamAndDevOps</a>, <a href="https://twitter.com/macromicah">@macromicah</a>, <a href="https://twitter.com/TheDudestMonk">@TheDudestMonk</a>, and <a href="https://twitter.com/tanyxp">@Tanyxp</a> for their additions.</p>
		</div>
	</div>
</article>
<article>
	<div class="post">
		<div class="article-title">
			<h1><a href="/archive/a-full-size-mirror/">
					A full size mirror
				</a>
			</h1>
			<small style="font-style:italic;">Posted on Sun, 20 Sep 2015 at 05:28 PM </small>
		</div> <!-- End article-title -->
		<div class="article-content">
			<p>Well <a href="/archive/a-mirror-for-posterity/">it is done</a>. A fully functioning <a href="http://mirror.brianschrader.com">mirror</a> of this site is available
over at <em>mirror.brianschrader.com</em>, and it's hosted by GitHub Pages, so it's
really fast.</p>
<p>Getting the mirror going was simple, because as I mentioned I alredy use Git 
for managing this site. Simply adding a new destination to publish to:</p>
<pre><code>git add remote mirror &lt;url&gt;
</code></pre>
<p>and adding that destination to my deployment script was all I needed to do.
Yay Git! </p>
<p>Thanks <a href="http://www.manton.org/2015/09/complete-mirror-of-this-blog.html">Manton for the awesome suggestion</a>. It's important that we, as a
community, try to persist our work. The web right now is ephemeral, so
individuals need to take the steps make sure their work is preserved.</p>
		</div>
	</div>
</article>
<article>
	<div class="post">
		<div class="article-title">
			<h1><a href="/archive/a-mirror-for-posterity/">
					A mirror for posterity
				</a>
			</h1>
			<small style="font-style:italic;">Posted on Sun, 20 Sep 2015 at 03:47 PM </small>
		</div> <!-- End article-title -->
		<div class="article-content">
			<p><a href="http://www.manton.org/2015/09/complete-mirror-of-this-blog.html">Manton Reece</a></p>
<blockquote>
<p>The default outcome for any site that isnâ€™t maintained â€” including the one
youâ€™re reading right now â€” is for it to vanish. Permanence doesnâ€™t exist on
the web.</p>
<p>Only 2 companies keep coming to mind: WordPress.com and GitHub. I believe
both will last for decades, maybe even 100 years, and both embrace the open
web in a way that most other centralized web sites do not.</p>
<p>Even though I self-host this weblog on WordPress, Iâ€™ve chosen to mirror to
GitHub because of their focus on simple, static publishing via GitHub Pages.
It has the best chance of running for a long time without intervention.</p>
</blockquote>
<p>This is a really cool idea. I've never thought about mirroring my site, and 
since I already use Git to push updates, adding a mirror is just adding another remote. </p>
<p><a href="http://www.manton.org/2015/09/complete-mirror-of-this-blog.html">Complete mirror of this blog &#8594;</a></p>
		</div>
	</div>
</article>
<article>
	<div class="post">
		<div class="article-title">
			<h1><a href="/archive/more-pluto-images/">
					More Pluto images
				</a>
			</h1>
			<small style="font-style:italic;">Posted on Sun, 20 Sep 2015 at 03:31 PM </small>
		</div> <!-- End article-title -->
		<div class="article-content">
			<p>NASA has released some new photos from New Horizons, and they're awsome. </p>
<p><img alt="A new backlit photo of Pluto from New Horizons" src="/images/blog/nasa-pluto-backlit.png" /></p>
<p><a href="https://www.nasa.gov/feature/pluto-wows-in-spectacular-new-backlit-panorama">Pluto â€˜Wowsâ€™ in Spectacular New Backlit Panorama &#8594;</a></p>
		</div>
	</div>
</article>
<article>
	<div class="post">
		<div class="article-title">
			<h1><a href="/archive/python-35-and-multitasking/">
					Python 3.5 and multitasking
				</a>
			</h1>
			<small style="font-style:italic;">Posted on Fri, 18 Sep 2015 at 08:19 AM </small>
		</div> <!-- End article-title -->
		<div class="article-content">
			<p>Python has a long and complicated history with multitasking. Strictly speaking
the <a href="http://www.dabeaz.com/GIL/">GIL</a> prevents a lot of classical attempts at multithreading for
arguably simpler application implementation. Therefore true multitasking in Python 
is available with multiprocessing, but the community tends to avoid it like the 
plague (for not undeserved reasons). With the release of Python 3.5, the community 
has very firmly cemented it's stance that multitasking should be done cooperatively 
using coroutines and generators, but as of yet the actual process of writing
multitasking code is still very complicated and I don't really understand why.</p>
<p>Back when I was doing iOS development, I got quite familiar with
Apple's <a href="https://en.wikipedia.org/wiki/Grand_Central_Dispatch">Grand Central Dispatch</a> API and I guess it spoiled me. The syntax
for kicking off calculations to separate threads, or returning to the main
thread for come quick UI updates is so simple. By comparison, Python's approach
seems overly complex. Granted, the two languages/environments are used
for different things. </p>
<p>Regardless, the newest version of Python (v3.5) adds support for a new
asynchronous function syntax. In short, this means that the old Python 
generator-based coroutines have been codified into a full on language feature. 
If you're like me, then you probably aren't to familiar with generator-based
coroutines, so this new syntax brings with it a host of new concepts to grok.</p>
<p><code class='python'><pre>
    async def some_function():
        pass
</pre></code></p>
<p>With the new release, I thought I'd do some testing to see, not only how the
new syntax works, but how well these new coroutines perform various tasks. At
work I need to manipulate fairly large files (~2-5GB of text) and I thought 
that I might be able to get some performance improvements by switching to using 
coroutines in Python 3.5. Currently, most of my code is plain-old sequential,
but I do have some auxiliary files that I generate during my analysis, and I'd 
like to be able to write out without stopping the main set of calculations to
wait for a slow-ass disk. At my first glance, coroutines seemed perfect.</p>
<h2>Time to test the new thing</h2>
<p>Right off the bat, the new syntax threw me into a torrent of confusion. I won't
get into my issues here, but suffice to say that having a coroutine
await some other coroutine which awaits some other coroutine is likely a way to 
get yourself confused fairly quickly.</p>
<p>One thing I wanted was to be able to use the new <code>async/await</code> syntax without
using <code>asyncio</code>. In my mind I shouldn't have to use a library to make the basic
syntax work, but that doesn't seem to be the case, and in the end I ended up having 
to use the event loop functions to get my code working. Once I discovered the 
secret of coroutines hidden in the documentation (and hidden quite well I'd say), 
I had some code that could finally be run asynchronously. </p>
<p>My goal was to have a few long-running tasks that would normally block, and
kick them off into a coroutine that would spin away while I did other things.
This is not how Python's coroutines work, and that becomes clear right away.</p>
<p>In short: Everything is asynchronous, or nothing is.</p>
<p>This mantra makes it really difficult to make Python code simple and serial and
still kick side work off to the coroutines. I understand that Python can only
do one thing at once, but the design of the <code>async/await</code> system seems really
punishing for little gain. </p>
<h2>Results</h2>
<p>Once I finally got the whole thing working, I devised some performance tests.
My 3 sets of test covered CPU bound, I/O bound, and a mix of CPU and I/O bound
computations, and each test would attempt all 5 of the usual Python
multitasking techniques: </p>
<ul>
<li>Serial execution (as a control)</li>
<li>Classical multithreading (which Python's GIL basically kills)</li>
<li>Classical multiprocessing</li>
<li>Python 3.5 Coroutines (with a threading pool, the default)</li>
<li>Python 3.5 Coroutines (with a process pool)</li>
</ul>
<p>I've published the test suite I used over <a href="https://github.com/Sonictherocketman/python3.5_coro_testing">on GitHub</a> if you want to check
it out for yourself. Overall, the results were really surprising.</p>
<p><center>
    <style type="text/css" scoped>td,th {text-align: center;}</style>
    <table cellspacing='12'>
        <tr>
            <th></th>
            <th>CPU bound</th>
            <th>I/O bound</th>
            <th>Both CPU/IO bound</th>
        </tr>
        <tr>
            <th>Test</th>
            <th>Time</th>
            <th>Time</th>
            <th>Time</th>
        </tr>
        <tr>
            <td>Serial</td>
            <td>7.804</td>
            <td>1.924s</td>
            <td>4.789s</td>
        </tr>
        <tr>
            <td>Coro Multi</td>
            <td>4.739s</td>
            <td>0.951s</td>
            <td>13.574s</td>
        </tr>
            <td>Coro Thread</td>
            <td>8.221s</td>
            <td>1.97s</td>
            <td>7.724s</td>
        </tr>
        <tr>
            <td>Multiprocess</td>
            <td>4.488s</td>
            <td>1.320s</td>
            <td>4.513s</td>
        </tr>
        <tr>
            <td>Threading</td>
            <td>8.251s</td>
            <td>1.807s</td>
            <td>4.976s</td>
        </tr>
    </table>
</center></p>
<p>While for I/O bound computations the coroutines improved performance quite
nicely with a multiprocessing pool behind it (even over conventional
multiprocessing), the moment you introduce CPU bound operations into the mix
everything goes to hell. In the case of using threading (which because of the
GIL was doomed before it began) it made the test ~9% slower. While the pure CPU
bound case did actually get somewhat faster (~40%) this is an unrealistic
benchmark since eventually you'd need to write something to disk. Once CPU 
and I/O operations get mixed together, for some reason, the execution time went 
<em>up</em> ~300%. This is certainly not the kind of behavior that I was expecting and 
it made me rethink my tests. On a second look everything seemed to be in order, 
but if you see something glaring out, please let me know.</p>
<p>One of the flaws that I see with my tests is that they don't use <a href="https://docs.python.org/3.5/library/asyncio.html"><code>asyncio</code></a>'s
native IO lib to write to the files, instead they wrap the synchronous <code>open</code>
and <code>write</code> calls from the standard library. I did this for two reasons, the
first being that I cannot, for the life of me, figure out how to use <code>asyncio</code>
to do local file IO and not a network request, but maybe <a href="https://twitter.com/sonicrocketman/status/471673517465800704">I'm just an idiot</a>. 
The second reason was because that's not how I'd imagine that I'd have to write
my code if I wanted to use this new functionality. I wrote this code how I
would expect that I would have to in Python. To me, this is an important reason
why I use Python. It's simple and expressive. I'd argue that, while <code>asyncio</code>
is amazingly powerful, simple and expressive it isn't. </p>
<p><a href="https://docs.python.org/3.5/library/asyncio.html"><code>asyncio</code></a> and the new syntax in Python 3.5 have all of the pieces needed for 
very simple multitasking, but they both stop short of making them easy to use for 
newcomers and typical users. Actually, thinking about it, they both feel a lot 
like  <code>urllib</code>: extremely powerful, but fairly complex for most use cases. Maybe, 
with  Python 3.5, it'll finally be time for <a href="http://docs.python-requests.org/en/latest/"><code>Async for humans</code>.</a> </p>
<script src="/bin/highlight.min.js"></script>

<p><link rel="stylesheet" href="/bin/highlight.default.min.css">
<script>hljs.initHighlightingOnLoad();</script></p>
<p><a href="https://github.com/Sonictherocketman/python3.5_coro_testing">Checkout my tests for yourself
&#8594;</a></p>
		</div>
	</div>
</article>	
			<div class="post">
				<div class="article-title"><a href="/archive/"><h3>Archive</h3></a></div>
			</div>
			<div style="text-align:center;">
				<div class="article-content">
					<span style="font-style:italic;">Subscribe to the <a href="/rss">RSS Feed</a>. Check out my code on <a href="http://github.com/sonictherocketman/">GitHub</a></span>
				</div>
				<div class="article-content">
					<span style="font-size:small;">
						<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
						<img alt="Creative Commons License" style="border-width:0" src="/images/misc/cc-license.png" />
						</a>
					<br />
					<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">BiteofanApple</span> is licensed under a 
					<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
				</div>
			</div>	
		</div> <!-- End post-list -->
	</div> <!-- End content -->
</body>
</html>
