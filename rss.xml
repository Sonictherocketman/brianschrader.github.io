<?xml version="1.0" encoding="iso-8859-1"?>
<rss version="2.0"><channel><title>BiteofanApple by Brian Schrader</title><link>http://brianschrader.com</link><description>Thoughts, and ramblings about technology, programming, history, and whatever else I'm interested in.</description><lastBuildDate>Thu, 07 Nov 2019 01:20:34 +0000</lastBuildDate><category>programming</category><category>history</category><category>science</category><category>personal</category><category>technology</category><generator>PyRSS2Gen-1.1.0</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><image><url>http://www.gravatar.com/avatar/11b074a636e00292c98e3e60f7e16595</url><title>sonicrocketman</title><link>http://brianschrader.com</link></image><item><title>High-Tech Empires</title><link>http://brianschrader.com/archive/high-tech-empires/</link><description>&lt;p&gt;&lt;a href="https://stratechery.com/2019/tech-and-liberty/"&gt;Ben Thompson &amp;#8594;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the long run, though, it is very problematic that such a powerful player in our democracy has no accountability. Liberty is not simply about laws, or culture, it is also about structure, and it is right to be concerned about the centralized nature of companies like Facebook.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://www.manton.org/2019/11/06/kill-the-algorithm.html"&gt;Manton Reece &amp;#8594;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Platforms that have as many problems as Facebook does can always be improved, but by design they can never be good enough because their size alone is one of the problems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A difference in scale can become a difference in kind. Facebook and other large Tech companies have more users than most nations have citizens. We look down on autocratic governments, and will hopefully continue to do so. We can't forget that these large corporations are a new form of the same thing.&lt;/p&gt;
&lt;p&gt;We have a words to describe organizations of large enough size that exert control over vastly different groups of people and that aren't answerable to their constituents. We call them autocracies; we call them empires.&lt;/p&gt;</description><category>social web</category><category> software</category><category> facebook</category><category> social media</category><guid isPermaLink="true">http://brianschrader.com/archive/high-tech-empires</guid><pubDate>Thu, 07 Nov 2019 01:20:00 -0800</pubDate></item><item><title>Remembering Things is Hard</title><link>http://brianschrader.com/archive/remembering-things-is-hard/</link><description>&lt;p&gt;I'm not very good at remembering things, even simple things, and I'm even worse at grinding (doing a simple or repetitive task more than once). That's one reason why I love being a developer: often times, I can script simple, repetitive, and common tasks.&lt;/p&gt;
&lt;p&gt;When it comes to development, although most of my projects leverage some form of automated continuous testing and linting, by the time I've pushed up my code and the tests have run, I've moved on to some other task. This means that when my code has a failing test or a linting error, I have to stop the new thing that I'm doing, stash my changes, and fix the error. I &lt;em&gt;should&lt;/em&gt; remember to run the tests before I push my code, but I never do.&lt;/p&gt;
&lt;p&gt;So in lieu of doing the hard work to remember to run the tests and becoming a better person in the process, I've written a &lt;code&gt;pre-commit&lt;/code&gt; script that runs before I commit my code. That way I can't commit my code without fixing the error, or explicitly ignoring it (with the &lt;code&gt;-n&lt;/code&gt; flag).*&lt;/p&gt;
&lt;div class="footnote"&gt;
* This also helps avoid the unprofessional looking "Fixes linting" commits.
&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;Here's my &lt;code&gt;.git/hooks/pre-commit&lt;/code&gt; file for any Django project. Give it a shot yourself and let me know if it helps you write better code.&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;#! /bin/bash
set -e;
log() { echo "[$(date)] $1"; }

cat &lt;&lt; EOF
-----------------------------------
Running the tests...
You might want to get a coffee. &#9749;&#65039;
-----------------------------------
log "Linting the code..."
flake8
log "Running the tests..."
./manage.py test
log "Done."
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css"&gt;
&lt;script src="http://yandex.st/highlightjs/8.0/highlight.min.js"&gt;&lt;/script&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;&lt;/p&gt;</description><category>code</category><category> software</category><category> preflight</category><category> git</category><guid isPermaLink="true">http://brianschrader.com/archive/remembering-things-is-hard</guid><pubDate>Sun, 03 Nov 2019 18:59:00 -0800</pubDate></item><item><title>Finally</title><link>http://brianschrader.com/archive/finally/</link><description>&lt;p&gt;Today marks the release of &lt;a href="https://blog.pine.blog/2019/10/fall-2019-update-hosted-blogs/"&gt;Pine.blog's Fall Update&lt;/a&gt;. It's a release I've been working on for months now and it feels great to finally get it out into the world. With this release, Pine.blog is now what I'd wanted it to be when I started &lt;a href="/archive/a-vision-of-the-open-web/"&gt;dreaming of what a the open web could do&lt;/a&gt;. On Pine.blog, you can follow your interests, keep up with the latest news, and join the conversation by starting a blog. I can finally say that the core features I want are in place.&lt;/p&gt;
&lt;p&gt;Obviously my goals for Pine.blog have expanded since I originally thought of the idea in 2014 (and began writing it in 2016), so there's still &lt;strong&gt;a lot to do&lt;/strong&gt;.&lt;/p&gt;</description><category>pine.blog</category><category> open web</category><category> rss</category><guid isPermaLink="true">http://brianschrader.com/archive/finally</guid><pubDate>Tue, 08 Oct 2019 01:34:00 -0800</pubDate></item><item><title>A New Adventure</title><link>http://brianschrader.com/archive/a-new-adventure/</link><description>&lt;p&gt;Last week, I bought a camera. I've wanted one for a while, but I'd never really looked around for something that would fit my needs. A few of my &lt;a href="https://www.instagram.com/photorayg/"&gt;friends&lt;/a&gt; and &lt;a href="http://www.museofadventure.com"&gt;family&lt;/a&gt; are actual photographers, and I knew that I didn't want to do what they do. I'd be carelessly jumping into a deep end to swim with reel big fish.&lt;/p&gt;
&lt;p&gt;I haven't owned a dedicated camera in over a decade. Ever since 2010, the only camera I've owned came with an iPhone attached to it. However, while the iPhone X's camera is great, it's just not enough for a whole myriad of situations, and in the last year I've found myself ever more limited by what my phone's camera could and couldn't do.&lt;/p&gt;
&lt;p&gt;There's an old adage: "the best camera is the one you have with you", and if I was going to have this camera with me, even a fraction of the time that I have my phone with me, it had to meet some pretty strict qualifications: It had to be really versatile (inter-changeable lenses was a hard requirement), it had to be compact enough to take almost anywhere, and it had to be a camera that could grow with me as I delve into this new-fangled world. So I talked to some people, read a bunch of articles, watched a bunch of reviews, and got this:&lt;/p&gt;
&lt;div style="text-align:center;"&gt;
    &lt;img
        alt="My new camera"
        src="/images/collections/a6000/camera-web.jpg"
        style="width:300px;margin-left:auto;margin-right:auto;"
    /&gt;
    &lt;caption&gt;
        &lt;a href="https://www.amazon.com/Sony-Mirrorless-Digitial-3-0-Inch-16-50mm/dp/B00I8BICB2/ref=sr_1_7?keywords=sony+a6000&amp;qid=1566087531&amp;s=gateway&amp;sr=8-7" title="The Sony &#945;6000"&gt;
            The Sony &#945;6000
        &lt;/a&gt;
    &lt;/caption&gt;
&lt;/div&gt;

&lt;p&gt;I've heard from quite a few people that Sony's &#945;6000 and &#945;6400 are really good for people who want a great camera, but aren't willing to dive into DSLRs. I don't know much about that second bit, but that description matched me to a T. As I've only had it a week so far, my opinions are still riddled with &lt;a href="https://www.urbandictionary.com/define.php?term=Ney%20Toy%20Syndrome"&gt;Ney Toy Syndrome&lt;/a&gt;. That said, I really like this camera. It's small and light enough to fit in the spare pocket of my daily carry bag, and it uses Sony's E-Mount which means that there's tons of compatible lenses, making it really versatile.&lt;/p&gt;
&lt;p&gt;I ended up getting the &#945;6000 mostly because of the price. The &#945;6400 was more than I wanted to spend and anything below the &#945;6000 didn't have a viewfinder, which was a dealbreaker. I'm still rocking the kit lens for now, but I plan on getting a 50/55mm Prime lens pretty soon. Before that though, I need to get a much more intuitive grasp of how to properly use what I have, and it'll probably take me a while to get the basics down.&lt;/p&gt;
&lt;h3&gt;A Checkpoint in Time&lt;/h3&gt;
&lt;p&gt;While I'll probably be posting most of the good shots I take to my &lt;a href="https://photos.brianschrader.com/"&gt;photoblog&lt;/a&gt;, below are a few of my favorite shots from the last week. I'm posting them here so that they serve as a record of my skills as a photographer right now. Hopefully, as time goes on and my skills improve, I'll look back on these pictures like I look back on old code I've written: with fond memories, and mild disgust.&lt;/p&gt;
&lt;div style="text-align:center;"&gt;
    &lt;a href="/images/collections/a6000/moonlight.jpg" title="Moonlight - Full Image"&gt;
        &lt;img
            alt="Moonlight"
            src="/images/collections/a6000/moonlight-web.jpg"
            style="display:inline-block;width:350px;margin-left:auto;margin-right:auto;"
        /&gt;
    &lt;/a&gt;
    &lt;a href="/images/collections/a6000/bark.jpg" title="Bark - Full Image"&gt;
        &lt;img
            alt="Bark"
            src="/images/collections/a6000/bark-web.jpg"
            style="display:inline-block;width:350px;margin-left:auto;margin-right:auto;"
        /&gt;
    &lt;/a&gt;
    &lt;a href="/images/collections/a6000/private.JPG" title="Private - Full Image"&gt;
        &lt;img
            alt="Private"
            src="/images/collections/a6000/private-web.jpg"
            style="display:inline-block;width:350px;margin-left:auto;margin-right:auto;"
        /&gt;
    &lt;/a&gt;
    &lt;a href="/images/collections/a6000/tank.JPG" title="Tank - Full Image"&gt;
        &lt;img
            alt="Tank"
            src="/images/collections/a6000/tank-web.jpg"
            style="display:inline-block;width:350px;margin-left:auto;margin-right:auto;"
        /&gt;
    &lt;/a&gt;
&lt;/div&gt;</description><category>photography</category><category> hobbies</category><category> money sink</category><category></category><guid isPermaLink="true">http://brianschrader.com/archive/a-new-adventure</guid><pubDate>Sun, 18 Aug 2019 01:25:00 -0800</pubDate></item><item><title>Don't Ban Infinite Scrolling, License Engineers Instead</title><link>http://brianschrader.com/archive/dont-ban-infinite-scrolling-license-engineers-instead/</link><description>&lt;p&gt;Yesterday, the &lt;a href="https://www.theverge.com/2019/7/30/20746878/josh-hawley-dark-patterns-platform-design-autoplay-youtube-videos-scrolling-snapstreaks-illegal"&gt;Verge reported that Sen. Josh Hawley sponsored&lt;/a&gt; a bill that aims to reduce the tech industry&#8217;s use of "addictive design" practices by putting a ban on features like infinite scrolling and autoplaying video. While I applaud Congress for focusing on this important issue, the proposed solution is both naive and unproductive. When a surgeon is accused of malpractice, the appropriate solution is not to ban their use of the scalpel, it's to revoke their license.&lt;/p&gt;
&lt;p&gt;I have long argued that Software Engineers (especially those at large companies that affect the lives of millions of people) &lt;a href="/archive/software-engineering/"&gt;should be licensed&lt;/a&gt;. Requiring a license to practice Software Engineering would finally place software in the realm of the other classical engineering fields and require practitioners to use their skills ethically and for the benefit of society. It would also help educate engineers on the risks and trade-offs with the decisions they make and give the government a lever to pull when trying to encourage ethical practices across the industry. Likewise, licensed engineers are able to refuse to implement unethical or unsafe designs when they fear that they could lose their license.&lt;/p&gt;
&lt;p&gt;One common argument against this point is that the tech industry is filled with lots of independent developers and others who operate relatively small businesses and that licensing them would put an damper on overall innovation in the industry. However, while we do often require Civil Engineers to have a license, we don't apply the same logic to carpenters, and we can apply the same kinds of criteria to Software Enginering licensure.&lt;/p&gt;
&lt;p&gt;We've required licenses for those practicing classical Engineering, Medicine, and Law for a long time&lt;sup&gt;1&lt;/sup&gt;, and those licenses have helped governments and the licensed individuals themselves steer industry practice away from things that can be considered unethical or unsafe. Instead of trying to take powerful tools away from Engineers, we should instead be focused on enabling and educating them to make ethical and societally beneficial decisions. The Internet is part of the infrastructure of our modern world, so let's ensure that the people who build and maintain it have society's best interests at heart.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;sup&gt;1&lt;/sup&gt; As an aside, we even license hairdressers and locksmiths. If unlocking cars or cutting hair requires a license, why doesn't building software that impacts 20% of the world's population?
&lt;/div&gt;</description><category>software engineering</category><category> ethics</category><category> legal</category><category></category><guid isPermaLink="true">http://brianschrader.com/archive/dont-ban-infinite-scrolling-license-engineers-instead</guid><pubDate>Wed, 31 Jul 2019 17:46:00 -0800</pubDate></item><item><title>The Social Web</title><link>http://brianschrader.com/archive/the-social-web/</link><description>&lt;p&gt;Things have been quiet here recently, and that's largely because I've been really busy working on lots of cool new stuff for &lt;a href="https://pine.blog/"&gt;Pine.blog&lt;/a&gt;. While the last few months have been full of steady progress, there's still a ways to go before the next set of features are ready for the world. If everything goes according to plan, the next major release should allow premium users to start their own blog on the site.&lt;/p&gt;
&lt;p&gt;So far, Pine.blog has been mostly focused on being a good feed reader, and while I think it is, there's so much more that can be done with feeds and blogs than just read them.&lt;/p&gt;
&lt;h3&gt;Feed Readers are the First Step&lt;/h3&gt;
&lt;p&gt;I've wanted Pine.blog to support custom blogs since the beginning, and that's largely because I think that by making it easier to both read and write on the open web, we can give people a viable alternative to more traditional social networks and offer them an escape from the problems those platforms have.&lt;/p&gt;
&lt;p&gt;Using tools and technologies that have existed for years, the web itself can be a social network, but in order for people to embrace that idea there have to be easy-to-use tools that are new and powerful, but also familiar and approchable, and importantly, there also have to be people to talk to; the web has to &lt;em&gt;feel&lt;/em&gt; like a social network.&lt;/p&gt;
&lt;h3&gt;Pushing Forward&lt;/h3&gt;
&lt;p&gt;One of the things I've come to strongly believe is that as developers (or as anyone who makes a thing) we can work to push the world toward we think it should be, and I think that the Web can and should be our shared social network.&lt;/p&gt;
&lt;p&gt;This is why I'm so excited by what I see as the future for Pine.blog. If we want people to move off of the platforms we think are the cause of so many problems in our world, we need to give those people a place to go. Most people aren't going to start a blog and use a feed reader unless we, as the people with the skills to do so, make the Social Web better than Social Media.&lt;/p&gt;</description><category>open web</category><category> social media</category><category> pine.blog</category><guid isPermaLink="true">http://brianschrader.com/archive/the-social-web</guid><pubDate>Sun, 28 Jul 2019 06:35:00 -0800</pubDate></item><item><title>Updates on using NSOperation</title><link>http://brianschrader.com/archive/updates-on-using-nsoperation/</link><description>&lt;p&gt;Last time &lt;a href="/archive/i-love-nsoperation/"&gt;I talked about NSOperation&lt;/a&gt;, I mentioned that I really liked using it to do things like networking and asynchronous operations in my app. Well, I've made a few tweaks to my &lt;code&gt;BackgroundNetworkingController&lt;/code&gt; recently (alas a new name was not among them) and I think the new version is even more readable and expressive.&lt;/p&gt;
&lt;p&gt;For those who don't know, NSOperation (or just Operation in Swift) is a class that when paired with (NS)OperationQueue allow you to order and track long running and often asynchronous tasks in your apps. You can use it to do API calls, animate transitions, walk a user through a process, and a lot more.&lt;/p&gt;
&lt;p&gt;In my last blog post I demoed this piece of code as an example of how I use Operations in the Pine.blog app.&lt;/p&gt;
&lt;p&gt;&lt;code class="swift"&gt;&lt;pre&gt;
func updateTimeline() {
    let reauthorize = TokenReauthorizationOperation()
    let fetchTimeline = FetchTimelineOperation()
    fetchTimeline.delegate = self
    fetchTimeline.addOperation(reauthorization)
    BackgroundQueueController.queue?.addOperations(
        [reauthorize, fetchTimeline],
        waitUntilFinished: false
    )
}
&lt;/pre&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;And while that example is pretty straight forward, I knew it could be better. There's so many times when I just need to tell my app: do these things in the background, in this order, and tell me when you're done (and let me know if something comes up). Operations allow me to do that, but setting up delegates and adding dependencies seems like cruft that I don't really want to care about.&lt;/p&gt;
&lt;p&gt;With that in mind, I added a new set of methods to my queue controller: &lt;code&gt;performInSeries(operations:)&lt;/code&gt; and &lt;code&gt;performInSeries(operations: with:)&lt;/code&gt;. Using those instead, the above example becomes:&lt;/p&gt;
&lt;p&gt;&lt;code class="swift"&gt;&lt;pre&gt;
BackgroundNetworkingController.performInSeries(
    operations: [
        TokenReauthorizationOperation(),
        FetchTimelineOperation(),
    ],
    with: self
)
&lt;/pre&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This code sets up the given operation with each previous operation as a dependency and assigns their delegate to &lt;code&gt;self&lt;/code&gt;. Reading this it becomes pretty clear that I want these operations to be performed in the order I specify and I want them to alert me if anything comes up, which is exactly what I want.&lt;/p&gt;
&lt;p&gt;Even the most complex uses in all of the Pine.blog app still retain their readability (aside from array concatenation). This example reauthorizes the user's token, then fetches the most recent posts in  each of the user's timelines, finds any new posts that the user has liked, and finally calls the given completionHandler to let the app know that it has completed updating its data.&lt;/p&gt;
&lt;p&gt;&lt;code class="swift"&gt;&lt;pre&gt;
BackgroundNetworkingController.performInSeries(
    operations:
        [ ReauthorizationTask() ]
        + timelines.map { FetchNewestPostsInTimeline(timeline: $0) }
        + [ FetchLikesOperation(), BlockOperation { completionHandler?(self.fetchResult) }],
    with: self
)
&lt;/pre&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;There's still a bit further I can go with this, but I'm really happy with the readability and clarity improvement that these changes have made to my codebase.&lt;/p&gt;
&lt;p&gt;&lt;link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css"&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"&gt;&lt;/script&gt;&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;&lt;/p&gt;</description><category>development</category><category> nsoperation</category><guid isPermaLink="true">http://brianschrader.com/archive/updates-on-using-nsoperation</guid><pubDate>Sat, 29 Jun 2019 19:31:00 -0800</pubDate></item><item><title>Lots of Little Things</title><link>http://brianschrader.com/archive/lots-of-little-things/</link><description>&lt;p&gt;Recently I've been focused on finishing the next set of major features for &lt;a href="https://pine.blog/"&gt;Pine.blog&lt;/a&gt;, but as happens from time-to-time I got a bit distracted and ended up knocking out a whole lot of little features that I've wanted to build for a long time. Today's update was entirely server-side, and I'll have a new update for the iOS app coming in a few days.&lt;/p&gt;
&lt;h3&gt;Wordpress Enhancements&lt;/h3&gt;
&lt;p&gt;In addition to making a lot of things just plain faster, I've also added a new &lt;a href="https://pine.blog/kb/add_external_blog"&gt;feature for Wordpress users&lt;/a&gt; so that when users post on their blog, Wordpress will automatically let Pine.blog know and their posts show up much more quickly in their (and other user's) timelines.&lt;/p&gt;
&lt;p&gt;For me, this feature involved yet another foray into undocumented XML-RPC APIs from over a decade ago. So much of the information just isn't easy to find anymore so building features that use them is more archeology than software development.&lt;/p&gt;
&lt;h3&gt;API Keys and Webhooks&lt;/h3&gt;
&lt;p&gt;Users that want to write scripts using Pine.blog (or build custom applications) can now get an API key quickly and easily that lets you access the full range of Pine.blog APIs.&lt;/p&gt;
&lt;p&gt;For those who want to dive even deeper into their data with Pine.blog, users can now add a Webhook URL if they'd like to receive updates from Pine.blog whenever a feed they're subscribed to changes.&lt;/p&gt;
&lt;h3&gt;API Documentation Revamp&lt;/h3&gt;
&lt;p&gt;I've completely redone the Pine.blog API documentation. Hopefully this makes it much easier for developers to discover and use the Pine.blog/Feed Directory API. The new documentation includes much more detailed information about the throttling limits, what to expect from each endpoint, and much much more. If you're looking to use the Pine.blog/Feed Directory API in your app or service &lt;a href="https://pine.blog/api/documentation"&gt;you can find out more from the documentation here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A lot of these developer-focused features are test runs for much broader features that I have cooking in the background. Meanwhile I'm trying to keep the majority of what I do with Pine.blog a lot more user-focused.&lt;/p&gt;</description><category>pine.blog</category><category> update</category><guid isPermaLink="true">http://brianschrader.com/archive/lots-of-little-things</guid><pubDate>Sat, 29 Jun 2019 04:02:00 -0800</pubDate></item><item><title>Changing Tides</title><link>http://brianschrader.com/archive/changing-tides/</link><description>&lt;p&gt;It's a big day: &lt;strong&gt;&lt;a href="https://pine.blog/?r=bs"&gt;Pine.blog&lt;/a&gt; is now free to use!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Pine.blog has been out for over a year now and it's been getting better and better over that time. However, although quite a few people have signed up, most have stopped short of signing up for a premium subscription. At first I thought that adding a free trial to Pine.blog would help, but that doesn't seem to do much to encourage signups.&lt;/p&gt;
&lt;p&gt;I want &lt;a href="https://pine.blog/?r=bs"&gt;Pine.blog&lt;/a&gt; to be useful to as many people as possible because I think Pine.blog and a lot of other Open Web tools (i.e. Micro.blog, Mastodon, etc) represent what social networking &lt;em&gt;should be&lt;/em&gt;. In order to reach a wide audience, Pine.blog needs to let people know what it is and then convince them to use it. I've made pretty good progress on that first goal: Pine.blog's traffic numbers keep going up and responses are generally positive, it's just that those numbers don't really translate into subscriptions.&lt;/p&gt;
&lt;p&gt;In that light, &lt;a href="https://pine.blog/?r=bs"&gt;Pine.blog&lt;/a&gt; no longer requires a subscription to use: just create a free account and you're good to go! If you want to organize your feeds into multiple timelines or start a blog&lt;sup&gt;*&lt;/sup&gt; you'll still need a premium subscription, and don't worry, you still get a free trial.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;At time of writing, the newest version of the iOS app is "Waiting for App Review", so you'll have to sign up on the website to start a free account, but you can use the app once you've created your account.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;sup&gt;*&lt;/sup&gt;Coming soon!
&lt;/div&gt;</description><category>software</category><category> pine.blog</category><category> payments</category><guid isPermaLink="true">http://brianschrader.com/archive/changing-tides</guid><pubDate>Sun, 09 Jun 2019 02:43:00 -0800</pubDate></item><item><title>The Hidden Cost of Cheap Hardware</title><link>http://brianschrader.com/archive/the-hidden-cost-of-cheap-hardware/</link><description>&lt;p&gt;Most times, when developers debate code-level optimizations, someone will eventually bring up the classic platitude:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Developer-time is more expensive than Compute-time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And it's true: paying a developer to optimize code is generally more expensive than adding additional hardware to run the existing, slow code faster. Servers and storage are so cheap these days that most developers don't need to know or care about the actual hardware that runs the code they write. Hardware is fast, cheap, and available in huge surplus, but this overabundance of cheap computing power has caused this throw-more-hardware-at-it mindset to proliferate into other aspects of development, namely how systems are designed.&lt;/p&gt;
&lt;h2&gt;Let's face it, modern web stacks are complex&lt;/h2&gt;
&lt;p&gt;A typical web stack contains a lot of co-dependent software, and Developers, Admins, and DevOps will each have their own tools to improve, manage, and add some semblance of comprehensibility to a running system. But, each additional proxy, app instance, and physical or virtual server adds multiple possible points of failure to your production system and lots of additional complexity to development.&lt;/p&gt;
&lt;p&gt;Over time, developers add more and more layers of software and tooling to their project until the hardware can't handle it anymore, and then instead of reevaluating their tools, they make the fateful decision to break the system out into smaller, isolated pieces, turning their simple website into a complex distributed system, because after all, adding hardware is cheaper, right?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"Complexity is a bug-lamp for smart people. We're just drawn to it."&lt;/p&gt;
&lt;p&gt;Maciej Ceg&#322;owski, &lt;a href="https://idlewords.com/talks/website_obesity.htm#top"&gt;The Website Obesity Crisis (2015)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The hardware is cheap, yes, but the developer-time needed to design a system who's pieces communicate over dozens of network connections and physical or virtual machines often far, far exceeds the costs of keeping things simpler from the get-go. Most small and medium systems can exist on very little hardware, and that, in turn, keeps the project design much simpler than spreading less efficient work over dozens of machines.&lt;/p&gt;
&lt;p&gt;None of this is to say that an unoptimized codebase is the same as a large or possibly over-engineered system, but there are parallels between them. Both are made possible because of the fact that we have cheap and abundant access to powerful hardware that can run inefficient code and all of the layers of abstraction that slow down and sometimes overcomplicate modern software. It might be then that developers working in these large systems, as with some developers working on inefficient code, might not realize just how powerful their hardware really is.&lt;/p&gt;
&lt;h2&gt;Empathy for the machine&lt;/h2&gt;
&lt;p&gt;Today's hardware is fast, really fast, and we can use that power to our advantage, but only if we, as developers, have an intuitive sense of just how fast it is.&lt;/p&gt;
&lt;p&gt;In a totally related, I promise, anecdote: An old coworker of mine was complaining one day that a Perl script he'd written took too long to run, and he didn't know why. I asked him how long it took, and he said, "About 2 seconds, but it should be instant." At first I thought it was silly that he was spending so much time optimizing for 2 seconds, but what I didn't know was that this script was only processing a few hundred kilobytes of testing data. Eventually, it would need to process a few hundred gigabytes. We had a High Performance Computing Cluster he could run his analysis on, but he didn't want to use it because, as he put it, "This analysis isn't complicated, it should be able to run on my machine". He didn't want to move his work to the cluster because he'd have to add a lot of code to ensure it would run correctly in a distributed environment that was harder to debug. After he fixed the issue, processing the test data took an imperceptible amount of time, and he was able to run the entire analysis on his 6-core workstation in a little under an hour.&lt;/p&gt;
&lt;p&gt;Without that kind of intuitive understanding of how much time a task "should take" it's extremely difficult to know when, or if, something is wrong. You might just assume that your analysis really does take 2 seconds, or that your webapp really does take 3 seconds to send a simple response, and that you need to use more powerful hardware to get it done. What's worse is that developing that intuition is harder and harder the further you are from the actual hardware. With layers of virtualization and tooling between developers and their hardware, it's difficult to perform controlled experiments, or do any sort of real comparisons between revisions. Your gut instinct is your only gauge.&lt;/p&gt;
&lt;h2&gt;We need some sort of an anchor&lt;/h2&gt;
&lt;div class="image-container"&gt;
    &lt;img
        class="image-right"
        src="/images/blog/some-sort-of-a-rock.jpg"
        style="width:300px;"
    /&gt;&lt;br /&gt;
    &lt;caption&gt;&lt;center&gt;&lt;small&gt;
    Defining Deviancy Down
    &lt;/small&gt;&lt;/center&gt;&lt;/caption&gt;
&lt;/div&gt;

&lt;p&gt;Armed with cheap hardware and the conventional wisdom that adding more servers is cheaper and easier than optimizing what we already have, we've arguably made our systems slower, more complicated, and over-engineered for the problems they claim to solve. It's time we all take a look at the systems we build, and ask ourselves if they need to be as complex as we're making them. We, as a community tend to want to copy what the big companies do, but those enormous companies have different needs than the rest of us. Facebook, Netflix, and Google have different problems than the vast majority of sites. We don't need to use their tooling, apply their designs, or live with their compromises, but we often do exactly that.&lt;/p&gt;
&lt;p&gt;What we need is some sort of test, one we can apply to our systems to anchor our thinking about what hardware our systems need day-to-day. I've half-joked several times that any website that has less than a hundred concurrent users should be able to run on my spare Raspberry Pi on my apartment's internet. If you're building a small-business site or internal tool, that same half-joke applies to your site too.&lt;sup&gt;1&lt;/sup&gt; Such a  small, cheap system-on-a-chip is way too fragile for any real, production use, but it's more than powerful enough to be a good testing rig. Get one, deploy your production system on it, and see if you can serve a hundred users quickly and efficiently. Older systems have done more with a lot less.&lt;/p&gt;
&lt;p&gt;We're not building a space ship here, just a website.&lt;sup&gt;2&lt;/sup&gt;&lt;/p&gt;
&lt;div class="footnote"&gt;
    &lt;sup&gt;1&lt;/sup&gt; My Raspberry Pi B+ (Quad-Core 800MHz CPU &amp; 1 GB of RAM) is hooked up to a 150x15 Mbps connection, and runs a standard build of Debian Linux. If you can't host your website on that, then you're either building a fairly complex site with lots of computing demands, or have some pretty inefficient code.&lt;br /&gt;
    &lt;sup&gt;2&lt;/sup&gt; Disregard this message if you actually are building space ships or otherwise very complex software that for obvious reasons cannot be run on a $35 SOC meant for teaching children. Web Devs building CRUD apps: you're not excluded.
&lt;/div&gt;</description><category>software development</category><category> programming</category><category> complexity</category><category> engineering</category><guid isPermaLink="true">http://brianschrader.com/archive/the-hidden-cost-of-cheap-hardware</guid><pubDate>Wed, 23 Jan 2019 18:08:00 -0800</pubDate></item></channel></rss>